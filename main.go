// 1. searcher() goes to dir ./files/*, try to read files .json, .tcx, .xml, .gpx
// 2. interface it and choose right reader()
// 3. reader() makes json to structure
// 4. reader() ask DB() to check for dubles and write new date in accordance table
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
)

func panicIf(err error) {
	if err != nil {
		panic(err)
	}
}

// google fit ==============================
type AutoGenerated struct {
	DataSource string      `json:"Data Source"`
	DataPoints []DataPoint `json:"Data Points"`
}

type DataPoint struct {
	FitValue           []FitVal `json:"fitValue"`
	OriginDataSourceID string   `json:"originDataSourceId"`
	EndTimeNanos       int64    `json:"endTimeNanos"`
	DataTypeName       string   `json:"dataTypeName"`
	StartTimeNanos     int64    `json:"startTimeNanos"`
	ModifiedTimeMillis int64    `json:"modifiedTimeMillis"`
	RawTimestampNanos  int      `json:"rawTimestampNanos"`
}

type FitVal struct {
	Value Valu `json:"value"`
}

type Valu struct {
	IntVal int     `json:"intVal"`
	FpVal  float64 `json:"fpVal"`
}

// ========================================
type errs struct {
	Err []string
}

var er errs

func main() {
	// read evn
	// connection DB =================================
	// godotenv.Load()

	// adr := os.Getenv("DBADR")
	// usr := os.Getenv("DBUSER")
	// pwd := os.Getenv("DBPWD")
	// dbs := os.Getenv("DBTYPE")
	// if adr == "" {
	// 	log.Printf("cant find DB specs in .env")
	// }
	// // connect to DB
	// db := pg.Connect(&pg.Options{
	// 	Addr:     adr,
	// 	User:     usr,
	// 	Password: pwd,
	// 	Database: dbs,
	// })
	// defer db.Close()
	//===============================================
	// println all tables available
	//f := AutoGenerated{}
	//f.DBselect(db)
	// goes to dir

	//
	fdir := "./data/googlefit/*.json"

	jsons, err := filepath.Glob(fdir)
	if err != nil {
		fmt.Println("json files not found", err)
	}
	googleqty := len(jsons)
	googlered := 0
	strokqty := 0
	strokred := 0
	valuetocheck := false
	for _, filename := range jsons {
		//var googlefit = make(AutoGenerated{})
		//_, err := ParseFile(filename) //, *googlefit)
		{
			f, err := os.Open(filename)
			if err != nil {
				er.Err = append(er.Err, fmt.Sprint("ERR: ", fdir, " Cant open file ", filename))
				continue
			}
			//defer f.Close()
			jsonParser := json.NewDecoder(f)
			var str AutoGenerated
			if err := jsonParser.Decode(&str); err != nil {
				er.Err = append(er.Err, fmt.Sprint("ERR: ", fdir, " Cant decode json. File name is ", filename))
				f.Close()
				continue
			}
			googlered += 1
			strokqty += len(str.DataPoints)
			for i, dataPoints := range str.DataPoints { // array in one file
				if len(dataPoints.FitValue) != 1 { // if some difference
					er.Err = append(er.Err, fmt.Sprint("ERR: Structure changed: Google Fit 'fitValue' is more than 1 in array. File name is ", filename, " error string is ", i))
					break
				}
				fitValue := dataPoints.FitValue[0]
				val := fitValue.Value //.IntVal
				// source := dataPoints.OriginDataSourceID
				// startTimeNanos := dataPoints.StartTimeNanos
				// endTimeNanos := dataPoints.EndTimeNanos
				// fmt.Println("DataSource ", str.DataSource,
				// 	"\nValue = ", val,
				// 	"\nSource = ", source,
				// 	"\nStart Time = ", time.Unix(0, startTimeNanos*int64(time.Nanosecond)),
				// 	"\nEnd Time = ", time.Unix(0, endTimeNanos*int64(time.Nanosecond)),
				// 	"\nCreation Date = ", time.Unix(0, dataPoints.ModifiedTimeMillis*int64(time.Millisecond)))
				strokred += 1
				valuetocheck = valuetocheck || val.IntVal != 0 || val.FpVal != 0.0

			}
			f.Close()
			if !valuetocheck {
				googlered -= 1
				er.Err = append(er.Err, fmt.Sprint("ERR: Wron value type in struct in ", filename, " or may be all val = 0?"))
			}
		}
		// if err != nil {
		// 	fmt.Println("Error parsing Google Fit", err)
		// }

	}
	fmt.Printf("Opened successfuly %d/%d files.\nRed successfuly %d/%d rows.\n", googlered, googleqty, strokred, strokqty)
	if googlered != googleqty || strokred != strokqty {
		for _, s := range er.Err {
			fmt.Println(s)
		}
	}
	//Dirviewer() // starts reader(fileadres)
}
